# Arxiv Analysis: Forest: Structural Code Editing with Multiple Cursors

**ID:** 2210.11124
**Date:** 2024-07-29
**Link:** https://arxiv.org/abs/2210.11124

## Executive Summary
The paper introduces "Forest," a structural code editor designed to combine the interactivity of modern IDEs with the power of programmatic refactoring scripts. Its key innovation is a structural multi-cursor design, which allows developers to perform a single, complex action simultaneously across multiple, related locations in the code. This approach enables expressive, specialized refactorings directly within the editor, addressing a gap where traditional editors are too simple and scripts are not interactive. The core value is providing a practical, interactive way to handle complex, small-scale refactoring tasks that are common in software development.

## Idea Brainstorming
*What concepts are potentially useful for THIS project?*
The core concept of "structural multi-cursor editing" can be abstracted from code editing and applied to multi-agent coordination and configuration. Instead of editing text, we are "editing" the behavior or configuration of multiple agents simultaneously.

- **Concept 1: Multi-Agent Command & Control:** The `DeepTraderManager` could use a "multi-cursor" command pattern. A single high-level directive (e.g., "Shift to risk-off posture") could be broadcast. This single command would act as the "edit," and each subscribed agent (`RiskAnalyst`, `Trader`, `PortfolioManager`) would be a "cursor," interpreting and applying the change within its own operational context (e.g., tighten stop-losses, reduce trade sizes, hedge positions). This is more robust than a simple pub/sub model because the command is structural and affects the entire "program" of the team's behavior.

- **Concept 2: Dynamic Prompt Scaffolding:** As the system moves toward the ARTEMIS architecture with a `PromptBuilder`, the multi-cursor idea can be used for dynamic prompt generation. A "scaffolding" or "meta-prompt" change could be applied to the prompts of multiple agents before they are spawned. For example, adding a new compliance constraint could be a single "edit" that injects the rule into the `PlannerAgent`, `Trader`, and `ComplianceOfficer` prompts, ensuring system-wide adherence from a single action.

- **Concept 3: Centralized Rule (`AgentSpec`) Propagation:** The `AgentSpec` system currently applies rules to toolkits. This could be extended to a multi-cursor model where a single rule in an `.ags` file can be explicitly targeted at multiple, disparate toolkits or agents. For example, a rule like `enforce timeout(5s) on_all_io_tools` could be defined once and structurally applied to `DexToolkit`, `MarketDataToolkit`, and any other tool with I/O, acting as a simultaneous edit on their configuration.

## Gap Analysis
*Compare paper concepts vs. `current_codebase`. What do we already have? What is missing?*

| Feature/Concept | Current State (Codebase) | Missing / Needed |
| :--- | :--- | :--- |
| **Multi-Agent Command & Control** | The `DeepTraderManager` coordinates a `Team` of agents. Some basic coordination exists via `TrafficRuleToolkit`. However, communication is largely point-to-point or relies on shared state/memory. | A formal pub/sub or command bus system is needed. Agents require handlers to subscribe to and interpret high-level "structural" commands, allowing one-to-many behavioral changes. |
| **Dynamic Prompt Scaffolding** | The architecture documents (`01-plan.md`) specify a plan to build a `PromptBuilder` as part of the ARTEMIS integration. The current implementation, however, still loads static `instructions.md` files for each agent. | The entire `PromptBuilder` domain is missing. This includes the template engine (e.g., Jinja2), the context injection mechanism, and the logic to apply a single "scaffold" change to multiple agent prompts. |
| **Centralized Rule Propagation** | The `AgentSpec` system is implemented and can apply rules from a `.ags` file to a toolkit. However, it's configured in a one-to-one fashion, wrapping a single `DexToolkit` instance. | The `AgentSpec` parser and enforcement engine need to be enhanced to support a one-to-many, "multi-cursor" mapping. The rule syntax itself would need to be extended to allow a single rule to target multiple, different toolkits or agents. |

## Implementation Plan
*Granular, step-by-step task list to port the ideas to our code.*

- [ ] **Task 1: Implement a Command Bus for Multi-Agent C2C**
    - [ ] Define a `Command` Pydantic model and a `CommandBus` interface.
    - [ ] Implement a `RedisCommandBus` for pub/sub functionality.
    - [ ] Refactor `DeepTraderManager` to publish commands instead of direct calls.
    - [ ] Add `subscribe` methods and handlers to subordinate agents (`RiskAnalyst`, `Trader`).

- [ ] **Task 2: Enhance AgentSpec for Multi-Toolkit Rule Propagation**
    - [ ] Modify the `.ags` grammar (ANTLR or similar) to support a `targets: [ToolkitA, ToolkitB]` syntax.
    - [ ] Update the `AgentSpecParser` to correctly parse the new multi-target syntax.
    - [ ] Modify the `apply_enforcement_to_toolkit` wrapper in `backend/agents/__init__.py` to iterate through the specified targets and apply the same enforcement instance to all of them.

- [ ] **Task 3: Build the Dynamic Prompt Scaffolding System (as per ARTEMIS plan)**
    - [ ] Implement the `PromptBuilder` class using Jinja2 for templating.
    - [ ] Create a `prompt_templates/` directory with base templates and partial "scaffolds."
    - [ ] Modify the `create_agent` factory in `backend/factory.py` to accept a context dictionary.
    - [ ] The factory should use the `PromptBuilder` to assemble the final instructions from scaffolds and context before instantiating the agent, replacing the static `instructions_path` loading.
