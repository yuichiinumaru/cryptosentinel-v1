# Arxiv Analysis: TaskGen - A Task-Based, Memory-Infused Agentic Framework

**ID:** 2407.15734
**Date:** 2024-07-25
**Link:** https://arxiv.org/abs/2407.15734

## Executive Summary
The paper introduces TaskGen, an open-source agentic framework designed for creating robust and efficient LLM-based agents. Its core philosophy is to decompose complex tasks into smaller, manageable subtasks, which are then mapped to specific "Equipped Functions" or other "Inner Agents". The framework's key innovation is its use of `StrictJSON`, which enforces concise, typed JSON outputs from the LLM, significantly reducing verbosity, token usage, and latency compared to traditional free-text or JSON Schema approaches. TaskGen also features a sophisticated memory model, including Shared Memory (for state persistence), Global Context (for dynamic environmental data), and a Memory Bank (for RAG), ensuring that information is shared between components on a need-to-know basis. This modular, task-based, and memory-infused architecture provides a strong foundation for building reliable and scalable multi-agent systems.

## Idea Brainstorming
*What concepts are potentially useful for THIS project?*
- **StrictJSON for Tool Definition:** The paper's `StrictJSON` approach is significantly more token-efficient than standard JSON Schema or Pydantic models for defining agent functions. We can adapt this for our `Toolkit` classes in `backend/tools/`. By creating a more concise representation of our tools for the LLM prompt, we could reduce latency and API costs while potentially improving the model's accuracy in selecting the right tool and parameters.

- **Formalized Task Decomposition:** The `DeepTraderManager` currently acts as a high-level coordinator. We can formalize its role to be a "Meta Agent" that explicitly breaks down complex user requests (e.g., "research ETH and place a trade") into a structured plan of subtasks. Each subtask would be mapped to an "Inner Agent" (`MarketAnalyst`, `RiskAnalyst`, `Trader`). This would replace implicit, conversational delegation with a more robust, task-driven workflow.

- **Explicit Shared Memory & Global Context:** The paper's concepts of "Shared Variables" and "Global Context" can improve inter-agent communication and environmental awareness.
    - **Shared Variables:** We can implement a formal `SharedMemory` object within each session to store and pass critical state between agents (e.g., `current_sentiment`, `risk_assessment`, `proposed_trade`). This is more explicit than agents parsing state from a long conversation history.
    - **Global Context:** Dynamic, system-wide state like the `TRADING_MODE` (PAPER/LIVE) or critical, real-time market data could be injected into every agent's prompt as `Global Context`. This ensures agents are always aware of the current operational environment without needing to use a tool.

- **Hierarchical Agent Responses:** When an "Inner Agent" (e.g., `MarketAnalyst`) completes its subtask, its final output should be a concise, structured summary (`StrictJSON` format) sent back to the `DeepTraderManager`, rather than a verbose, natural-language response. The paper notes this reduces the context length for the Meta Agent, helping it stay focused on the high-level plan.

## Gap Analysis
*Compare paper concepts vs. `current_codebase`. What do we already have? What is missing?*

| Feature/Concept | Current State (Codebase) | Missing / Needed |
| :--- | :--- | :--- |
| **Concise Tool Definitions** | Toolkits in `backend/tools/` use standard Python docstrings and type hints. The `Agno` framework likely converts these into a verbose, JSON Schema-like format for the LLM. | A custom utility to convert Python Toolkit classes into the token-efficient `StrictJSON` format. This would reduce prompt size and potentially improve tool-selection accuracy. |
| **Formal Task Decomposition** | The `DeepTraderManager` coordinates agents conversationally. Delegation is implicit and reactive, based on the flow of the chat history. There's no explicit, pre-defined plan of subtasks. | The `DeepTraderManager` needs to be enhanced to act as a "Meta Agent". Its first responsibility should be to generate a structured plan (a list of subtasks with target agents and instructions) before executing it. |
| **Explicit Shared Memory** | State is shared implicitly through the conversational history managed by the `Agno` `Team` object. Agents must parse this history to infer the current state. Long-term state is in an SQLite DB. | An explicit, session-based `SharedMemory` object is needed. This object would hold ephemeral state (`sentiment`, `risk_level`, etc.) and be passed to or made accessible by all agents in the session for reliable state management. |
| **Global Context Injection** | System-wide state (like `TRADING_MODE`) is accessed via environment variables (`os.getenv`), but it is not automatically and consistently injected into every agent's context. | A mechanism to prepend a "Global Context" block to each agent's system prompt is required. This would ensure all agents are aware of the current operational environment at all times. This could be integrated into the `create_agent` factory. |
| **Hierarchical Agent Responses** | "Inner Agents" (e.g., `MarketAnalyst`) return verbose, natural language string outputs that the manager agent has to interpret. | Inner agents' `run` methods should be modified to return structured, concise `StrictJSON` objects. This provides a reliable, machine-readable output for the `DeepTraderManager` to consume, making its decision-making process more robust. |

## Implementation Plan
*Granular, step-by-step task list to port the ideas to our code.*

- [ ] **Phase 1: Foundational Tooling (StrictJSON)**
    - [ ] **Task 1.1: Create a `StrictJSON` Tool Formatter.**
        - Create a new module `backend/tools/strict_json_formatter.py`.
        - Implement a function that introspects a `Toolkit` class and generates a concise, token-efficient string representation of its tools, following the `StrictJSON` paper's principles (e.g., `function_name(param: type) -> description`).
    - [ ] **Task 1.2: Integrate Formatter into Agent Creation.**
        - Modify the `create_agent` factory in `backend/factory.py` to accept the new formatter.
        - Update the agent creation process to use this formatter when constructing the tool list for the LLM's system prompt.

- [ ] **Phase 2: State and Context Management**
    - [ ] **Task 2.1: Implement `SharedMemory` Class.**
        - Create `backend/memory/shared_memory.py` with a `SharedMemory` class to act as a session-level key-value store.
        - In `backend/agents/__init__.py`, instantiate `SharedMemory` and ensure it's passed to every agent in the team.
    - [ ] **Task 2.2: Implement Global Context Injection.**
        - In `backend/factory.py`, add logic to the `create_agent` function to build a `global_context` string from environment variables (e.g., `TRADING_MODE`).
        - Prepend this context string to the system prompt for every created agent to ensure consistent environmental awareness.

- [ ] **Phase 3: Meta Agent & Task-Driven Workflow**
    - [ ] **Task 3.1: Refactor `DeepTraderManager` to a Meta Agent.**
        - Update `backend/DeepTraderManager/instructions.md` to redefine its role: it must first analyze a user request and output a structured plan of subtasks in `StrictJSON` format.
        - The plan should specify the sequence of "Inner Agents" to call and the instructions for each.
    - [ ] **Task 3.2: Standardize Inner Agent Outputs.**
        - Update the instructions for `MarketAnalyst`, `RiskAnalyst`, and `Trader` to mandate that their final output must be a concise `StrictJSON` object summarizing their result, not a natural language paragraph.
    - [ ] **Task 3.3: Update Orchestration Logic.**
        - Modify the `chat` endpoint in `backend/main.py` or the `Team` class to handle the new workflow: 1) Call `DeepTraderManager` to generate a plan, 2) Sequentially execute the plan by calling the specified inner agents, passing `SharedMemory`, and 3) Use the structured outputs to inform the next step in the plan.
