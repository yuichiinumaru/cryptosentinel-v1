The kukapay/cryptopanic-mcp-server project on GitHub 19 provides an example of an MCP server that likely utilizes web scraping to deliver cryptocurrency news to AI agents. While the README.md does not explicitly mention Scrapy, the server's functionality – fetching the latest cryptocurrency news from CryptoPanic – suggests the use of a web scraping library. The server implements a single tool, get\_crypto\_news, which allows users to specify the type of content (news, analysis, videos) and the number of pages to fetch. The server is implemented in Python and requires a CryptoPanic API key for configuration. The project structure 19 includes main.py, which is likely the main script that handles the MCP server logic and the web scraping process. The existence of other MCP servers by the same author 20, such as those for crypto sentiment analysis and whale tracking, indicates a focus on providing cryptocurrency-related information to AI agents through the MCP protocol. This example illustrates how MCP can be used to access and structure data from web sources, even when dedicated APIs are not available. However, it is important to note that web scraping can be more susceptible to website changes, requiring ongoing maintenance of the scraping logic. The need for an API key in this project also highlights that even when scraping, there might be terms of service or usage limitations imposed by the data provider.

## **Asynchronous Operations: Efficiently Handling External API Calls in MCP**

Interacting with external APIs, whether for trading, data retrieval, or web scraping, often involves network requests that can introduce significant latency. If these operations are performed synchronously, the MCP server can become unresponsive, waiting for each request to complete before handling the next. Asynchronous programming provides a solution to this problem by allowing the server to initiate multiple requests concurrently without blocking the main execution thread 21.

Python's asyncio library, along with the async and await keywords, provides a powerful framework for writing asynchronous code 21. By defining functions as coroutines using async def, developers can pause and resume their execution at await points, allowing other tasks to run in the meantime. This is particularly beneficial when dealing with I/O-bound operations like network requests. The asyncio.gather() function can be used to concurrently run multiple asynchronous operations and wait for their completion 21.

Within an MCP server, the methods of ToolProvider and ResourceProvider that interact with external APIs should be implemented as asynchronous functions using async def. Libraries like aiohttp can be used to make asynchronous HTTP requests in Python 21. Notably, the CCXT library also offers asynchronous methods for interacting with cryptocurrency exchanges 12. The modelcontextprotocol Python SDK itself provides support for asynchronous operations. For instance, the Context object available within tool and resource handlers offers asynchronous methods like ctx.read\_resource(), as demonstrated in 2. This indicates that the SDK is designed to facilitate asynchronous interactions, enabling developers to build efficient and responsive MCP servers. The Nayshins/mcp-server-ccxt project explicitly mentions leveraging CCXT's asynchronous support for efficient exchange communication 12, highlighting the importance of this approach in real-world implementations. While the other example projects might not explicitly detail their asynchronous handling in their documentation, the nature of their operations (interacting with external APIs) strongly suggests the use of asynchronous techniques to maintain performance and responsiveness.

## **Schema Definition: Ensuring Clarity and Structure in MCP Tool Interactions**

Defining clear and well-structured schemas for the input parameters and output responses of MCP tools is essential for ensuring seamless communication and reliable operation. Schemas act as contracts between the LLM client and the MCP server, specifying the expected data types, formats, and constraints for each tool's interaction. This not only facilitates validation, ensuring that the LLM provides the necessary information in the correct format, but also enables the LLM to understand and interpret the server's responses effectively 7.

The modelcontextprotocol Python SDK provides mechanisms for defining these schemas, likely leveraging standard Python type hints or integration with schema definition libraries. Input schemas can specify whether parameters are required or optional, their data types (such as string, integer, boolean, or list), and any applicable constraints (e.g., minimum or maximum values, regular expression patterns). Similarly, output schemas define the structure and data types of the information that the tool will return.

Consider the example of the get-price tool in the CCXT server. Its input schema might specify a required parameter ticker of type string and an optional parameter exchange of type string with a default value of "binance". The output schema could define a response object containing a price field of type float and a timestamp field representing the time the price was retrieved. For the get-historical-ohlcv tool, the input schema would likely include parameters for the ticker, exchange, timeframe (e.g., "1h", "1d"), and an optional limit for the number of data points to return, each with appropriate data types. The output schema would then define a list of objects, where each object represents a candlestick with fields for timestamp, open, high, low, close, and volume, all with their corresponding data types. Similarly, for the Etherscan server's check-balance tool, the input schema would require an address of type string, and the output schema could specify fields for balance\_wei (string) and balance\_eth (float). For the web scraping tool get\_crypto\_news, the input schema might define optional parameters for kind (string, with an enumeration of allowed values like "news", "analysis", "videos") and num\_pages (integer, with a default and a maximum value), while the output schema could be a list of news articles, each with fields for title (string), url (string), source (string), and published\_at (datetime). These examples illustrate how schemas provide a clear and structured definition of the data exchanged during MCP tool interactions, ensuring both the client and the server operate with a shared understanding.

## **Advanced Considerations and Challenges**

Building robust and production-ready MCP servers for financial and web APIs involves addressing several advanced considerations and potential challenges. Interacting with external APIs inherently introduces the possibility of errors due to network issues, API downtime, or invalid requests. Therefore, implementing robust error handling and exception management is crucial. The Nayshins/mcp-server-ccxt project 12, for instance, handles errors such as invalid trading pairs, exchange connectivity problems, rate limiting, malformed requests, and network timeouts. This demonstrates the range of issues that developers need to anticipate and manage. The MCP Java SDK 7 also emphasizes the importance of unified error handling for both synchronous and asynchronous operations.

Another significant challenge is managing API rate limits and throttling. Most external APIs impose restrictions on the number of requests that can be made within a certain time period. MCP servers need to implement strategies to handle these limits gracefully, such as introducing delays between requests, using exponential backoff mechanisms for retries 21, or employing connection pooling to optimize resource usage 12.

Security is paramount when dealing with financial APIs that often require API keys or other sensitive credentials. These credentials must be handled with utmost care on the MCP server and should never be exposed directly to the LLM client. Best practices include storing API keys as environment variables, using secure configuration files with restricted access, or leveraging dedicated secret management services. Snippet 13 discusses various authentication and authorization approaches in the context of MCP, highlighting the trust placed in the server to securely manage such sensitive information.

For applications that require high-frequency or real-time data, performance optimization becomes a critical concern. Techniques such as caching API responses, using efficient data structures for processing, and leveraging asynchronous operations are essential for building performant MCP servers. The use of asynchronous communication with exchanges in the CCXT server 12 is a testament to this requirement in the domain of financial APIs.

## **Comparative Analysis and Best Practices**

Examining the example projects (Nayshins/mcp-server-ccxt, 5ajaki/mcp-etherscan-server, kukapay/cryptopanic-mcp-server) reveals distinct implementation patterns tailored to the specific types of APIs they wrap. The Nayshins/mcp-server-ccxt project, written in Python, focuses on providing a comprehensive suite of tools for accessing cryptocurrency exchange data through the CCXT library. Its use of asynchronous CCXT methods indicates a design choice for efficient handling of multiple exchange interactions. In contrast, the 5ajaki/mcp-etherscan-server, implemented in TypeScript, offers a more modular set of tools specifically for interacting with the Etherscan API, providing functionalities like balance checks and transaction retrieval. The kukapay/cryptopanic-mcp-server, another Python-based project, takes a different approach by implementing a single tool for fetching cryptocurrency news, likely relying on web scraping techniques.

| Project Name | Programming Language | Primary API/Data Source | Focus/Functionality | Asynchronous Handling | Authentication Method | Key Features |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| Nayshins/mcp-server-ccxt | Python | CCXT | Broad range of cryptocurrency exchange market data | Yes | Likely env variables | Real-time prices, historical data, market summaries, multiple exchange support |
| 5ajaki/mcp-etherscan-server | TypeScript | Etherscan | Specific tools for Ethereum blockchain data | Likely | Env variable (API key) | Balance checks, transaction history, contract ABI, gas prices, ENS resolution |
| kukapay/cryptopanic-mcp-server | Python | CryptoPanic (Scraped) | Fetching latest cryptocurrency news | Likely | API key in config | Single tool with parameters for content type and number of pages |

These examples illustrate that the choice of programming language and the granularity of the exposed tools can vary depending on the specific requirements. For trading APIs like CCXT, a comprehensive set of tools that mirror the library's capabilities, combined with asynchronous operations for performance and secure server-side authentication, appears to be an effective strategy. For data APIs like Etherscan, a more focused approach with specific tools for different data points might be preferable. When dealing with web scraping, the implementation might involve a more limited set of tools focused on extracting particular information, with careful consideration for handling website changes.

Based on the analysis of these projects and the broader considerations discussed, several best practices emerge for building scalable and maintainable MCP servers for financial and web APIs. Utilizing asynchronous programming is crucial for handling the potentially high latency and concurrent nature of external API calls. Defining clear schemas for the input and output of all tools ensures clarity and facilitates validation. Implementing robust error handling and comprehensive logging is essential for debugging and maintaining the server's reliability. Effective management of API rate limits is necessary to prevent service disruptions. Securely handling API keys and other sensitive data is paramount, especially for financial applications. Employing configuration management for API keys and other settings can improve security and flexibility. Structuring the codebase logically, writing unit and integration tests, and considering containerization with tools like Docker can significantly enhance the maintainability and deployability of the MCP server.

## **Conclusion: Empowering AI with Real-Time Financial and Web Data through MCP**

The Model Context Protocol offers a promising pathway for integrating the vast resources of financial and web APIs with the increasing capabilities of Large Language Models. By providing a standardized and secure framework, MCP simplifies the complexities traditionally associated with such integrations, enabling developers to build more intelligent and context-aware AI applications. The ToolProvider and ResourceProvider abstractions within the modelcontextprotocol Python SDK offer powerful mechanisms for exposing API functionalities in a structured and accessible manner.

The analysis of example projects like Nayshins/mcp-server-ccxt, 5ajaki/mcp-etherscan-server, and kukapay/cryptopanic-mcp-server demonstrates practical approaches to wrapping trading, data, and web scraping APIs within MCP servers. These examples highlight the importance of asynchronous programming for performance, the necessity of clear schema definitions for tool interactions, and the critical considerations around error handling, rate limit management, and security.

As the MCP ecosystem continues to evolve, with the development of new servers and tools, the potential for AI applications to leverage real-time financial and web data will only expand. Adhering to the best practices outlined in this report, such as employing asynchronous operations, defining clear schemas, and prioritizing security, will be crucial for building scalable, reliable, and maintainable MCP servers that can effectively empower AI with the information it needs to perform complex tasks and provide valuable insights. MCP represents a significant advancement in bridging the gap between the capabilities of AI models and the wealth of information available through external APIs, paving the way for a new generation of intelligent applications.

#### **Works cited**

1. Model Context Protocol (MCP): Redefining AI Data Integration with Anthropic, accessed March 26, 2025, [https://pwraitools.com/generative-ai-tools/anthropic-model-context-protocol-revolutionizing-ai-data-integration/](https://pwraitools.com/generative-ai-tools/anthropic-model-context-protocol-revolutionizing-ai-data-integration/)
2. The official Python SDK for Model Context Protocol servers and clients \- GitHub, accessed March 26, 2025, [https://github.com/modelcontextprotocol/python-sdk](https://github.com/modelcontextprotocol/python-sdk)
3. Model context protocol (MCP) \- OpenAI Agents SDK, accessed March 26, 2025, [https://openai.github.io/openai-agents-python/mcp/](https://openai.github.io/openai-agents-python/mcp/)
4. Model Context Protocol (MCP). The USB-C of AI: Standardizing AI ..., accessed March 26, 2025, [https://medium.com/@AIWithNaveenKrishnan/model-context-protocol-mcp-edbe8466cf45](https://medium.com/@AIWithNaveenKrishnan/model-context-protocol-mcp-edbe8466cf45)
5. How to Build an MCP Server for AI | by Naman Tripathi | Mar, 2025 ..., accessed March 26, 2025, [https://medium.com/@naman1011/how-to-build-an-mcp-server-for-ai-6877730db98a](https://medium.com/@naman1011/how-to-build-an-mcp-server-for-ai-6877730db98a)
6. Using the Model Context Protocol with Quarkus+LangChain4j, accessed March 26, 2025, [https://quarkus.io/blog/quarkus-langchain4j-mcp/](https://quarkus.io/blog/quarkus-langchain4j-mcp/)
7. MCP Server \- Model Context Protocol, accessed March 26, 2025, [https://modelcontextprotocol.io/sdk/java/mcp-server](https://modelcontextprotocol.io/sdk/java/mcp-server)
8. For Server Developers \- Model Context Protocol, accessed March 26, 2025, [https://modelcontextprotocol.io/quickstart/server](https://modelcontextprotocol.io/quickstart/server)
9. Model Context Protocol (MCP) \- LangChain4j, accessed March 26, 2025, [https://docs.langchain4j.dev/tutorials/mcp/](https://docs.langchain4j.dev/tutorials/mcp/)
10. mcp\_rs \- crates.io: Rust Package Registry, accessed March 26, 2025, [https://crates.io/crates/mcp\_rs](https://crates.io/crates/mcp_rs)
11. async-mcp \- crates.io: Rust Package Registry, accessed March 26, 2025, [https://crates.io/crates/async-mcp](https://crates.io/crates/async-mcp)
12. Nayshins/mcp-server-ccxt: Cryptocurrency Market Data ... \- GitHub, accessed March 26, 2025, [https://github.com/Nayshins/mcp-server-ccxt](https://github.com/Nayshins/mcp-server-ccxt)
13. Authentication · modelcontextprotocol specification · Discussion \#64 \- GitHub, accessed March 26, 2025, [https://github.com/modelcontextprotocol/specification/discussions/64](https://github.com/modelcontextprotocol/specification/discussions/64)
14. Dockerfile \- Nayshins/mcp-server-ccxt \- GitHub, accessed March 26, 2025, [https://github.com/Nayshins/mcp-server-ccxt/blob/main/Dockerfile](https://github.com/Nayshins/mcp-server-ccxt/blob/main/Dockerfile)
15. Releases · Nayshins/mcp-server-ccxt \- GitHub, accessed March 26, 2025, [https://github.com/Nayshins/mcp-server-ccxt/releases](https://github.com/Nayshins/mcp-server-ccxt/releases)
16. 5ajaki/mcp-etherscan-server \- GitHub, accessed March 26, 2025, [https://github.com/5ajaki/mcp-etherscan-server](https://github.com/5ajaki/mcp-etherscan-server)
17. 5ajaki/veri5ight: MCP Server for Ethereum Node \- GitHub, accessed March 26, 2025, [https://github.com/5ajaki/veri5ight](https://github.com/5ajaki/veri5ight)
18. 5ajaki \- Safe MCP Server \- GitHub, accessed March 26, 2025, [https://github.com/MCP-Mirror/5ajaki\_safe-mcp-server](https://github.com/MCP-Mirror/5ajaki_safe-mcp-server)
