O desenvolvimento de sistemas multiagentes complexos exige uma atenção meticulosa ao gerenciamento do estado e ao fluxo de dados entre os agentes. Em frameworks como o Agency Swarm, que visa simplificar a criação de agências de IA colaborativas, o manuseio eficiente de dados estruturados e a persistência do estado entre as execuções dos agentes são cruciais para construir aplicações robustas e escaláveis. Este relatório explora os padrões e estratégias para gerenciar o estado persistente e trocar dados complexos dentro do Agency Swarm, com foco nos detalhes relevantes para desenvolvedores experientes.

## **Arquitetura do Agency Swarm e Gerenciamento de Estado**

O Agency Swarm foi concebido como um framework para automatizar agências de IA, permitindo a criação de swarms de agentes com funções e capacidades distintas 1. Uma característica fundamental é o gerenciamento eficiente do estado dos assistentes na OpenAI, que é mantido em um arquivo settings.json especial 1. Essa abordagem permite que o framework persista informações importantes entre diferentes execuções de agentes.

As ferramentas (BaseTool) dentro do Agency Swarm são criadas usando o Instructor, que oferece uma interface conveniente e validação automática de tipos 1. Para que essas ferramentas acessem ou persistam estado entre diferentes execuções, o Agency Swarm fornece um mecanismo de shared\_state 3. Essa variável compartilhada entre todas as ferramentas e agentes permite controlar o fluxo de execução, compartilhar dados e fornecer instruções com base em condições ou ações realizadas por outros agentes 3.

## **Persistência de Estado em Ferramentas (BaseTool)**

Dentro do Agency Swarm, a persistência de estado para ferramentas (BaseTool) pode ser alcançada através do acesso e modificação do shared\_state dentro do método run de uma ferramenta personalizada 3. O shared\_state funciona como um dicionário acessível a todas as ferramentas e agentes dentro da agência.

Para acessar dados persistentes, o método get() do shared\_state pode ser utilizado, fornecendo uma chave e um valor padrão opcional caso a chave não seja encontrada. Para armazenar ou atualizar dados, o método set() é empregado, aceitando uma chave e o valor a ser armazenado.

Um exemplo prático dessa funcionalidade é demonstrado na conversão de uma ferramenta para responder perguntas com citações validadas 3. A ferramenta QueryDatabase verifica se o contexto já foi recuperado no shared\_state, recupera o contexto e o salva usando self.\_shared\_state.set("context", context) 3. A ferramenta AnswerQuestion então acessa esse contexto do shared\_state para responder à pergunta e, posteriormente, remove o contexto para garantir que a próxima pergunta seja respondida com um contexto novo 3.

Embora o Agency Swarm gerencie o estado dos assistentes na OpenAI em um arquivo settings.json, a persistência de estado específica para ferramentas entre execuções é primariamente gerenciada através do shared\_state 1. Os snippets fornecidos não indicam suporte nativo a padrões de projeto como singletons ou injeção de dependência para persistência de estado em ferramentas. No entanto, a natureza flexível do Python e a capacidade de criar ferramentas personalizadas permitem que os desenvolvedores implementem esses padrões dentro de suas ferramentas, se necessário. Por exemplo, um singleton poderia ser implementado dentro de uma classe de ferramenta personalizada para garantir que apenas uma instância de um recurso (como um modelo de ML carregado) seja mantida em memória e acessada através do shared\_state.

## **Serialização e Desserialização de Objetos Python Complexos**

A troca de dados complexos entre agentes ou como parâmetros/retornos de ferramentas exige estratégias eficazes de serialização e desserialização. Embora o artigo mencione que as ferramentas são criadas com Instructor e possuem validação de tipo automática, ele não recomenda explicitamente formatos de serialização específicos para dados complexos. No entanto, considerando o ecossistema Python, JSON e Pickle são opções comuns.

JSON (JavaScript Object Notation) é um formato leve de intercâmbio de dados, de fácil leitura e gravação para humanos e de fácil análise e geração para máquinas 5. É amplamente utilizado em aplicações web e APIs devido à sua compatibilidade entre diferentes linguagens de programação 6. Para objetos Python complexos, como DataFrames ou dicionários aninhados, a biblioteca json do Python pode ser usada para serializar esses objetos em strings JSON e vice-versa 5.

Pickle é um módulo Python para serialização de objetos Python 5. Ele permite converter objetos Python complexos em um fluxo de bytes, facilitando o armazenamento ou a transmissão 5. O Pickle suporta a serialização da maioria dos tipos de dados embutidos em Python e objetos personalizados 7. No entanto, é crucial notar que o Pickle tem implicações de segurança significativas, pois dados pickle podem conter código malicioso que é executado durante a desserialização 5. Portanto, o Pickle deve ser usado com cautela, especialmente ao lidar com dados de fontes não confiáveis.

Formatos customizados também podem ser considerados para necessidades específicas, mas exigem mais esforço de implementação e podem reduzir a interoperabilidade com outros sistemas 5.

No contexto do Agency Swarm, a escolha do formato de serialização dependerá dos requisitos específicos do fluxo de trabalho e das considerações de segurança. Dada a ênfase do framework na comunicação eficiente e na validação de tipos com Instructor, é provável que objetos complexos sejam serializados para troca através do SendMessage ou como parâmetros/retornos de ferramentas usando JSON devido à sua segurança e interoperabilidade. No entanto, para persistência de estado interno que não requer interoperabilidade externa e onde a segurança não é uma preocupação imediata (por exemplo, manter um modelo de ML carregado na memória através do shared\_state), Pickle pode ser considerado, com as devidas ressalvas de segurança.

A biblioteca AgentParse é mencionada como uma biblioteca de parsing de alto desempenho projetada para mapear vários formatos de dados estruturados (como modelos Pydantic, JSON, YAML e CSV) em blocos compreensíveis por agentes 9. Embora não seja especificamente uma extensão do Agency Swarm, ela destaca a importância de lidar com diferentes formatos de dados em sistemas multiagentes e sugere que bibliotecas externas podem ser utilizadas para auxiliar nessa tarefa.

**Tabela 1: Comparação de Formatos de Serialização**

| Formato | Tipos de Dados Suportados | Desempenho (Velocidade, Tamanho) | Considerações de Segurança | Legibilidade Humana | Casos de Uso em Agency Swarm |
| :---- | :---- | :---- | :---- | :---- | :---- |
| JSON | Tipos de dados básicos (números, strings, booleanos, listas, dicionários) | Geralmente rápido e eficiente para dados simples | Seguro para troca de dados | Alta | Troca de mensagens entre agentes, parâmetros de ferramentas |
| Pickle | Quase todos os objetos Python | Rápido para serialização/desserialização de objetos Python | Risco de execução de código malicioso | Baixa | Persistência de estado interno (com cautela) |
| Customizado | Definido pelo desenvolvedor | Depende da implementação | Depende da implementação | Depende da implementação | Casos de uso específicos com requisitos únicos |

## **Coordenação de Tarefas e Passagem de Estado Intermediário**

O Agency Swarm permite a coordenação de tarefas complexas que exigem múltiplos passos ou a colaboração de vários agentes através de fluxos de comunicação definidos 2. Ao contrário de outros frameworks, os fluxos de comunicação no Agency Swarm não são estritamente hierárquicos ou sequenciais, mas sim uniformes e definidos de esquerda para direita no agency\_chart 13. Isso permite que um agente inicie a comunicação com outros agentes especificados e receba respostas no mesmo thread, facilitando a passagem de estado intermediário através das mensagens.

O conceito de shared\_state também desempenha um papel crucial na coordenação de tarefas complexas 3. Ele permite que diferentes agentes e ferramentas compartilhem informações e controlem o fluxo de execução ao longo de múltiplos passos. Por exemplo, um agente pode usar uma ferramenta para realizar uma análise inicial e armazenar os resultados intermediários no shared\_state. Outro agente, em um passo subsequente, pode acessar esses resultados através de outra ferramenta e continuar o processo.

Embora o Agency Swarm não ofereça explicitamente padrões de coordenação nomeados, os princípios de inteligência de enxame, como especialização com coordenação, podem ser aplicados 14. Isso envolve atribuir funções específicas a cada agente, garantir protocolos claros de handoff (transferência de controle) e manter um contexto compartilhado. A passagem de estado intermediário é inerente a esses padrões, pois os agentes comunicam e compartilham informações para progredir na tarefa.

Outras arquiteturas de swarm, como as sequenciais, onde a saída de um agente se torna a entrada para o próximo, podem ser implementadas no Agency Swarm definindo cuidadosamente os fluxos de comunicação no agency\_chart e utilizando o SendMessage para passar o estado intermediário 15. Da mesma forma, arquiteturas hierárquicas, com agentes coordenadores delegando tarefas, também podem ser construídas 15.

O conceito de "handoffs", onde um agente transfere o controle para outro, é fundamental em muitos sistemas multiagentes 11. No Agency Swarm, isso é realizado através do SendMessage, onde um agente instrui outro a realizar a próxima etapa da tarefa, possivelmente incluindo dados intermediários na mensagem.

## **Comparação com Outros Frameworks Multiagentes**

Ao comparar o Agency Swarm com outros frameworks multiagentes proeminentes, como AutoGen e CrewAI, algumas diferenças notáveis emergem em relação ao gerenciamento de estado e fluxo de dados.

O AutoGen, por padrão, determina o próximo agente a se manifestar com uma chamada extra ao modelo, o que pode ser ineficiente e menos controlável 1. Embora tenha adicionado suporte para determinar o próximo orador com base em condições codificadas, isso pode limitar a adaptabilidade do sistema 1. O Agency Swarm, por outro lado, utiliza uma ferramenta SendMessage especial, permitindo que os agentes decidam com quem se comunicar com base em suas próprias descrições e nos limites definidos no agency\_chart 1. Em termos de gerenciamento de estado, o AutoGen oferece mais opções para persistência e compartilhamento de contexto entre agentes, incluindo memória compartilhada e a capacidade de usar diferentes tipos de armazenamento de memória.

O CrewAI introduz um conceito de "processo" na comunicação entre agentes, oferecendo algum controle sobre o fluxo 1. No entanto, é construído sobre o Langchain, que foi criado antes do surgimento de modelos com capability de function-calling, resultando em falta de verificação de tipo e correção de erros 1. O Agency Swarm, ao utilizar o Instructor, previne alucinações com verificação automática de tipo e correção de erros 1. Em relação ao gerenciamento de estado, o CrewAI depende dos recursos fornecidos pelo Langchain, que incluem várias opções de memória.

O LangGraph, outro framework relevante, representa agentes como nós em um grafo, onde cada agente executa seus passos e decide se finaliza a execução ou roteia para outro agente 19. Ele oferece mecanismos explícitos para handoffs e permite definir subgrafos de agentes com esquemas de estado separados ou funções de nó de agente com esquemas de entrada privados 19. O Agency Swarm, embora permita fluxos de comunicação flexíveis, não possui uma representação gráfica nativa de workflows ou mecanismos de handoff tão explícitos quanto o LangGraph.

O Swarms, um framework experimental da OpenAI, foca em agentes e handoffs como primitivos principais, utilizando variáveis de contexto para manter o estado entre as interações dos agentes 11. Ele opera com uma arquitetura stateless, o que significa que não retém informações entre as chamadas, exigindo que os desenvolvedores gerenciem o contexto externamente ou através de variáveis de contexto 21. O Agency Swarm, ao manter o estado em um arquivo settings.json e oferecer o shared\_state, fornece mais suporte nativo para persistência de estado em comparação com o Swarms.

Em resumo, o Agency Swarm se destaca pelo controle sobre prompts e ferramentas type-safe, mas pode ter menos recursos nativos para gerenciamento de estado e orquestração de workflows complexos em comparação com frameworks como AutoGen e LangGraph.

**Tabela 2: Comparação de Gerenciamento de Estado e Dados em Frameworks Multiagentes**

| Framework | Comunicação entre Agentes | Mecanismos de Persistência de Estado | Manuseio de Dados Complexos | Orquestração de Workflow | Pontos Fortes | Limitações Potenciais |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| Agency Swarm | Ferramenta SendMessage baseada em descrições de agentes | Arquivo settings.json para estado do assistente, shared\_state para ferramentas | Depende da serialização (JSON, Pickle); Instructor para validação de tipo | Fluxos de comunicação definidos no agency\_chart, shared\_state para controle de fluxo | Controle de prompts, ferramentas type-safe, comunicação eficiente | Menos recursos nativos para gerenciamento de estado avançado e orquestração explícita |
| AutoGen | Determinação dinâmica do próximo orador (padrão), condições codificadas | Memória compartilhada, diferentes tipos de armazenamento de memória | Suporta vários formatos através de ferramentas e funções | Flexível, com suporte para diferentes padrões de conversação e workflows | Pode ser ineficiente na determinação do próximo orador (padrão) |  |
| CrewAI | Conceito de "processo" para controlar o fluxo de comunicação | Depende dos recursos de memória do Langchain | Depende das capacidades do Langchain | Baseado em tarefas e agentes com papéis definidos | Compatível com modelos open-source | Falta de verificação de tipo e correção de erros nativas |
| LangGraph | Agentes como nós em um grafo, handoffs explícitos | Estado mantido no grafo, esquemas de estado separados para subgrafos | Depende das ferramentas e funções dos agentes | Representação gráfica de workflows, handoffs explícitos, roteamento baseado em comandos | Controle granular sobre o fluxo de execução, modularidade | Pode exigir mais configuração e abstração para workflows simples |
| Swarms (OpenAI) | Handoffs entre agentes | Variáveis de contexto compartilhadas entre as chamadas | Depende das funções dos agentes | Baseado em handoffs e rotinas, arquitetura stateless | Simples, leve, focado em handoffs | Stateless, gerenciamento de estado pode ser mais complexo para tarefas longas |

## **Considerações de Segurança e Desempenho**

A escolha do formato de serialização em sistemas multiagentes como o Agency Swarm tem implicações significativas para a segurança e o desempenho.

Em termos de segurança, o uso de Pickle para serializar dados, especialmente aqueles recebidos de fontes não confiáveis, apresenta um risco considerável 5. A desserialização de um fluxo de bytes pickle pode levar à execução de código arbitrário, tornando o sistema vulnerável a ataques 5. Portanto, para troca de mensagens entre agentes ou ao lidar com dados externos, JSON é geralmente uma opção mais segura devido à sua natureza baseada em texto e à ausência de capacidade de execução de código 6.

No que diz respeito ao desempenho, a serialização e desserialização de objetos complexos podem impactar a velocidade e o consumo de recursos do sistema. O Pickle tende a ser mais rápido para serializar e desserializar objetos Python complexos em comparação com JSON, pois ele opera em um nível mais baixo e preserva a estrutura do objeto nativo 5. No entanto, a diferença de desempenho pode não ser significativa para objetos menores ou em sistemas onde a segurança é uma prioridade maior. Para objetos muito grandes ou em cenários de alto desempenho, formatos binários customizados poderiam ser considerados, mas com o custo de maior complexidade de implementação e menor interoperabilidade 5.

No contexto do Agency Swarm, onde a comunicação eficiente é um objetivo chave 1, a escolha do formato de serialização deve equilibrar as necessidades de velocidade, segurança e compatibilidade. Dada a integração com Instructor para validação de tipo, é provável que a serialização para troca de mensagens utilize formatos que se integrem bem com essa validação, como JSON. Para persistência de estado interno através do shared\_state, onde o controle sobre a fonte dos dados é maior, o Pickle pode ser usado com cautela, considerando os trade-offs de segurança.

## **Bibliotecas e Extensões Recomendadas**

O Agency Swarm já utiliza a biblioteca pydantic para definição de tipos e validação de dados dentro das ferramentas (BaseTool) 2. Para auxiliar ainda mais no gerenciamento de estado persistente e na troca de dados complexos, algumas bibliotecas adicionais podem ser consideradas.

Para a serialização e desserialização eficientes de objetos Python complexos para JSON, especialmente aqueles que não são diretamente serializáveis (como DataFrames do pandas), a própria biblioteca pandas fornece métodos como to\_json() e read\_json() 6. Outras bibliotecas como marshmallow também podem ser úteis para serialização e desserialização mais complexas com validação de esquema 6.

No que diz respeito ao gerenciamento de estado persistente além do shared\_state, os desenvolvedores podem considerar a integração com bancos de dados externos ou sistemas de armazenamento chave-valor, dependendo dos requisitos de sua aplicação. Bibliotecas como SQLAlchemy para bancos de dados relacionais ou redis-py para Redis podem ser utilizadas dentro das ferramentas do Agency Swarm para persistir e recuperar estado de forma mais robusta.
